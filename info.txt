for file transfer 
create socket for both client ande server

for client

call socket in login close and download function
in login socket , address = sock.accept() 
in close call socket in list of args
in download from connection_common ---> data_recive ---> data.write()
created a thread and pass accordinglly


for server

call socket in login close and upload function
in login socket.socket - connect (ip,port)
in close call socket in list of args
in upload send_data ---> file open ---> send_data(socket,size_of_header,data)












    # def screen_sharing():
#     root = tk.Tk()
#     root.title("Screen Sharing")
#     # create a canvas to display the screenshots
#     canvas = tk.Canvas(root, width=800, height=600)
#     canvas.pack()
#     # function to update the canvas with a new screenshot
#     def update_canvas():
#         with mss.mss() as sct:
#             # define the region to capture (in this case, the whole screen)
#             monitor = sct.monitors[1]
#             rect = {
#                 "left": monitor["left"],
#                 "top": monitor["top"],
#                 "width": monitor["width"],
#                 "height": monitor["height"]
#             }
            
#             # capture the screen and convert it to a tkinter PhotoImage
#             sct_img = sct.grab(rect)
#             photo = ImageTk.PhotoImage(Image.frombytes("RGB", sct_img.size, sct_img.bgra, "raw", "BGRX"))
            
#             # update the canvas with the new screenshot
#             canvas.create_image(0, 0, anchor=tk.NW, image=photo)
#             canvas.image = photo
            
#             # schedule the next update after 100ms
#             root.after(100, update_canvas)
#         # screen_sending()
#     update_canvas()
    # messagebox.showinfo("Remote Box", "Connected! Choose an option:")
# choice = messagebox.askyesno("Remote Box", "Do you want to share your screen?")
                    
# if choice:
#     # perform screen sharing
#     screen_sharing()              
 # def generate_password():
#     PASSWORD = "".join(random.choices(string.ascii_uppercase + string.digits, k=6))
#     current_time = datetime.datetime.now()

#     # Set the expiration time to 1 hour from now
#     expiration_time = current_time + datetime.timedelta(minutes=1)
#     if current_time == expiration_time:
#       print("password expire")
#       close_socket()
#       process_cleanup()
      
#     return PASSWORD, expiration_time

     
